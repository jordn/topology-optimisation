import os

def ensure_dir(f):
    d = os.path.dirname(f)
    if not os.path.exists(d):
        os.makedirs(d)
    return d

def generatetpd(
    prob_name = 'temp_problem',
    vol_frac = 0.5,
    num_iter = 50,
    eta = 0.5,
    filt_rad = 1.5,
    p_fac = 2,
    elem_k = 'Q4',
    **kwargs
    ):

    if prob_name == 'temp_problem':
        prob_name = "volfrac_%.1f_filtrad_%1.1f_eta_%1.1f"%(vol_frac, filt_rad, eta)
    
    tpd_filename= prob_name + '.tpd'
    f = open(tpd_filename, 'w')

    tpd_contents = "[ToPy Problem Definition File v2007]\n"
    tpd_contents += "# TPD file generated by tpd-generator.py\n\n"

    #Problem name (for output)
    tpd_contents += "PROB_NAME  : %s\n"%(prob_name)

    # ============================
    # === Algorithm Parameters ===
    # ============================
    tpd_contents += "PROB_TYPE  : comp\n" #comp/heat/mech

    tpd_contents += "VOL_FRAC   : %s\n" %(vol_frac) #comp/heat/mech

    tpd_contents += "NUM_ITER   : %s\n" %(num_iter) #Runs for set iterations
    # tpd_contents += "CHG_STOP  : %s\n" %(chg_stop) #or, runs until objective function value changes < this.

    tpd_contents += "ETA        : %s\n" %(eta)# DAMPING FACTOR. use 0.001, 0.5 for reciprical, 'exp' for exponentional
    # approx = 'dquad' # possible to use diagonal quadratic approximation, not sure why anyone would however
    
    tpd_contents += "ELEM_K     : %s\n" %(elem_k) #Matrix to use for FEA. Other 2D: Q5B, Q4a5B, Q4T.   3D: H8, H18B, H8T.

    # =========================
    # === Grey Scale Filter ===
    # =========================

    tpd_contents += "FILT_RAD   : %s\n" %(filt_rad) #Filter radius, something to do with the grey-scale filter to cut off okish pixels

    tpd_contents += "P_FAC      : %s\n" %(p_fac) #penalty factor (p), default 3
    
    if 'p_hold' in kwargs:
        tpd_contents += "P_HOLD     : %s\n" %(kwargs['p_hold']) # number of turns to hold p at the start
    if 'p_max' in kwargs:
        tpd_contents += "P_MAX      : %s\n" %(kwargs['p_max']) # max p, default 3.5
    if 'p_incr' in kwargs:
        tpd_contents += "P_INCR     : %s\n" %(kwargs['p_incr']) # how much to increase p by, default 0.02
    if 'p_con' in kwargs:
        tpd_contents += "P_CON      : %s\n" %(kwargs['p_con']) # how many iterations before we increment p, default 25
    
    if 'q_hold' in kwargs:
        tqd_contents += "Q_HOLD     : %s\n" %(kwargs['q_hold']) # number of turns to hold q at the start
    if 'q_max' in kwargs:
        tqd_contents += "Q_MAX      : %s\n" %(kwargs['q_max']) # max q, default 3.5
    if 'q_incr' in kwargs:
        tqd_contents += "Q_INCR     : %s\n" %(kwargs['q_incr']) # how much to increase q by, default 0.02
    if 'q_con' in kwargs:
        tqd_contents += "Q_CON      : %s\n" %(kwargs['q_con']) # how many iterations before we increment q, default 25
    


    # q_fac = 1# extra penalty factor (q) TBD
    # q_max = 5 # max q
    # q_incr = 0.08  #how much to increase q by ??
    # q_con = 20 # after increment, how many iterations to keep p constants



    # ===========================
    # === Physical parameters ===
    # ===========================
    dof_pn = 2  #DOF for each element, essentially are we doing 2 or 3D
    num_elem_x = 1201 #Number of elements in the X-direction.
    num_elem_y = 200 #  Number of elements in the (negative) Y-direction.
    # num_elem_z = 10

    # ==================================================
    # === Passive (void) and active (solid) elements ===
    # ==================================================
    # List the *element* numbers you want to affect.
    # PASV_ELEM: 10|19; 30|39; 50|59; 70|79; 90|99
    # ACTV_ELEM: 1|1181|20; 1181|1200


    # =================================
    # === Translational constraints ===
    # =================================
    # Node number(s) and/or 'start|stop|step' notation may be used for multiple
    # nodes, ";" may be used to separate ranges. NOTE: Do not end a line with a ";" Ends up as a big list.
    # FXTR_NODE_X = FiX TRanslation of NODE in the X direction
    fxtr_node_x = '1|21' #1|21             # Node 1 to 21, step size 1 is implied.
    fxtr_node_y = '1281'               #  Lower right corner for 60x20 problem
    fxtr_node_z = '1; 4|13|3; 18|22|2' #  Nodes 1, 4, 7, 10, 13, 18, 20, 22.

    # =============
    # === Loads ===
    # =============
    # A load value (VALU) *must* be specified for the nodes you choose. Use + or -
    # to set the direction of the load (+ is 'up', - is 'down).
    # Set the *node number(s)* that's loaded, *not* the degrees of freedom, that's
    # taken care of by ToPy. Assign values for the corresponding load size(s).
    # Also note the use of the "@" below, which is rather convenient for the user.
    load_node_x = '1; 4; 9' #  Load nodes 1, 4 and 9.
    load_node_y = '1      ' #  Upper left corner -- node number = 1 (always).
    # load_node_z = '20|32|3' #  Load node 20 to 32 in steps of 3.
    load_valu_x = '0.75   ' #  Simply omit a line if not necessary for your problem.
    load_valu_y = '-1     ' #  Value of the load = 1, direction negative Y (down).
    # load_valu_z = '1@10   ' #  Value of the load = 1 at 10 nodes in Z direction
    #ignoring heat conduction and mechanism design parameters.


    tpd_contents += """
DOF_PN     : 2
NUM_ELEM_X : 1000
NUM_ELEM_Y : 200
NUM_ELEM_Z : 0
PASV_ELEM  : 99801;100001
FXTR_NODE_Y: 1005;200196
LOAD_NODE_Y: 100502
LOAD_VALU_Y: 1

Q_FAC      : 1
Q_HOLD     : 50  # num of iters to hold q constant from start
Q_INCR     : 0.05  # increment by this amount
Q_CON      : 1  # increment every 'Q_CON' iters
Q_MAX      : 5  # max value of 'Q_CON'


"""

    print tpd_contents

    f.write(tpd_contents)
    f.close()

    return tpd_filename

